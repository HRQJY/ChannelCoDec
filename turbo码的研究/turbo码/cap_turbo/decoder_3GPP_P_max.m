%****************************************************************
% 内容概述：利用硬件化的方式实现TURBO码的p-MAX-LOG-MAP译码
%          生成矩阵按照3GPP标准为[1 1 0 1;1 0 1 1]
%          未使用另外一个译码器反馈的外部信息
%          输入为经过高斯信道的RSC软输入，而输出为软输出
% 创 建 人：朱殿荣/QQ:235347/MSN:njzdr@msn.com
% 单    位：南京邮电大学，通信工程系
% 创建时间：2005年7月16日
% 修改时间：
% 参考文献：《数字通信－－基础与应用》
%          《High performace parallelised 3GPP Turbo Decoder》
%          《改进的Turbo码算法及其FPGA实现过程的研究》,天津大学，张宁，赵雅兴
% 版权声明：任何人均可复制、传播、修改此文件，同时需保留原始版权信息。
%****************************************************************

clear;
x=[0.8 -0.7 0.86 0.68];   %输入系统位 对应输入信息是 [1 -1 1 1]
y=[0.9 0.96 -0.69 0.85];    %输入校验位
%---初始化&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Infty = -128;
pi=1;
d(1:2,1:4)=zeros(2,4);        %分支量度，2种可能结果，输入为-1或者1
                                %D(i,k)
a(1:8,1:4)=Infty*ones(8,4);     %前向分支量度，A(S,k)
a(1,1)=0;                       %寄存器状态由全零开始
b(1:8,1:5)=Infty*ones(8,5);     %后向分支量度，B(S,k)
b(1,5)=0;                       %寄存器状态由全零结束
va1(1:8,1)=zeros(8,1);
va0(1:8,1)=zeros(8,1);
va0_index=[2 1 4 3 6 5 8 7]';
a2a_index=([4 0 1 5 6 2 3 7]+1)';
vb1(1:8,1)=zeros(8,1);
vb0(1:8,1)=zeros(8,1);
vb0_index=[5 6 7 8 1 2 3 4]';
b2b_index=([1 2 5 6 0 3 4 7]+1)';

%计算分支量度D-----------------
%k=1&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
k=1;
d(1,k)=pi*(x(k)+y(k));
d(2,k)=pi*(x(k)-y(k));
%k=1时的前向状态量度已经初始化，无需计算。

%k=2&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
k=2;
d(1,k)=pi*(x(k)+y(k));
d(2,k)=pi*(x(k)-y(k));
%其他分支量度为0，已经在初始化时设定，每个k时无需计算。
va1=a(:,k-1)+[d(1,k);d(1,k);d(2,k);d(2,k);d(2,k);d(2,k);d(1,k);d(1,k)];
va0=a(:,k-1)-[d(1,k);d(1,k);d(2,k);d(2,k);d(2,k);d(2,k);d(1,k);d(1,k)];
va0=va0(va0_index);
a(:,k)=max(va0,va1);
a(a2a_index,k)=a(:,k);

%k=3&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
k=3;
d(1,k)=pi*(x(k)+y(k));
d(2,k)=pi*(x(k)-y(k));
%其他分支量度为0，已经在初始化时设定，每个k时无需计算。
va1=a(:,k-1)+[d(1,k);d(1,k);d(2,k);d(2,k);d(2,k);d(2,k);d(1,k);d(1,k)];
va0=a(:,k-1)-[d(1,k);d(1,k);d(2,k);d(2,k);d(2,k);d(2,k);d(1,k);d(1,k)];
va0=va0(va0_index);
a(:,k)=max(va0,va1);
a(a2a_index,k)=a(:,k);

%k=4&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
k=4;
d(1,k)=pi*(x(k)+y(k));
d(2,k)=pi*(x(k)-y(k));
%其他分支量度为0，已经在初始化时设定，每个k时无需计算。
va1=a(:,k-1)+[d(1,k);d(1,k);d(2,k);d(2,k);d(2,k);d(2,k);d(1,k);d(1,k)];
va0=a(:,k-1)-[d(1,k);d(1,k);d(2,k);d(2,k);d(2,k);d(2,k);d(1,k);d(1,k)];
va0=va0(va0_index);
a(:,k)=max(va0,va1);
a(a2a_index,k)=a(:,k);
%开始计算后向分支度量
vb1=b(:,k+1)+[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=b(:,k+1)-[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=vb0(vb0_index);
b(:,k)=max(vb0,vb1);
b(b2b_index,k)=b(:,k);
%开始计算LLR；
llr_a=a(b2b_index,k);
llr(k)=max(llr_a+vb1)-max(llr_a+vb0);

%k=3&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
k=3;
%计算后向分支度量
vb1=b(:,k+1)+[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=b(:,k+1)-[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=vb0(vb0_index);
b(:,k)=max(vb0,vb1);
b(b2b_index,k)=b(:,k);
%计算LLR；
llr_a=a(b2b_index,k);
llr(k)=max(llr_a+vb1)-max(llr_a+vb0);

%k=2&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
k=2;
%计算后向分支度量
vb1=b(:,k+1)+[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=b(:,k+1)-[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=vb0(vb0_index);
b(:,k)=max(vb0,vb1);
b(b2b_index,k)=b(:,k);
%计算LLR；
llr_a=a(b2b_index,k);
llr(k)=max(llr_a+vb1)-max(llr_a+vb0);

%k=1&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
k=1;
%计算后向分支度量
vb1=b(:,k+1)+[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=b(:,k+1)-[d(1,k);d(2,k);d(2,k);d(1,k);d(1,k);d(2,k);d(2,k);d(1,k)];
vb0=vb0(vb0_index);
b(:,k)=max(vb0,vb1);
b(b2b_index,k)=b(:,k);
%计算LLR；
llr_a=a(b2b_index,k);
llr(k)=max(llr_a+vb1)-max(llr_a+vb0);
